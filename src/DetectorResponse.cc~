#include "TRandom3.h"
#include <cmath>
#include "datastruct/TPulseIsland.h"
#include <iostream>

class DetectorResponse {

public:
	DetectorResponse();

private:
	TRandom3 fRandom;
	// Pulse Information
	double fRiseTime; // ns
	double fDecayTime; // ns
	double fSigma; // ns
	double fThreshold; // keV
	int fPolarity;
	// Resolution and Noise
	double fWhiteNoise; // keV
	double fCalibration;
	// Digitization
	double fFrequency; // GHz
	double fTickLength; // ns
	double fMaxEnergy; // keV
	int fNBits;
	int fMaxADC;
	int fPedestal;
	int fNSamples;
	int fNPreSamples;

public:
	// Pulse *etters
	void SetRiseTime(double rt) {
		fRiseTime = rt;
	}
	double GetRiseTime() {
		return fRiseTime;
	}
	void SetDecayTime(double dt) {
		fDecayTime = dt;
	}
	double GetDecayTime() {
		return fDecayTime;
	}
	void SetSigma(double s) {
		fSigma = s;
	}
	double GetSigma() {
		return fSigma;
	}
	void SetThreshold(double th) {
		fThreshold = th;
	}
	double GetThreshold() {
		return fThreshold;
	}
	void SetPolarity(int po) {
		if (po < 0)
			fPolarity = -1;
		else
			fPolarity = 1;
	}
	int GetPolarity() {
		return fPolarity;
	}
	// Resolution and Noise *etters
	void SetWhiteNoise(double n) {
		fWhiteNoise = n;
	}
	double GetWhiteNoise() {
		return fWhiteNoise;
	}
	void SetCalibration(double ca) {
		fCalibration = ca;
	}
	double GetCalibration() {
		return fCalibration;
	}
	// Digitization *etters
	void SetFrequency(double fr) {
		fFrequency = fr;
		fTickLength = 1. / fr;
	}
	double GetFrequency() {
		return fFrequency;
	}
	double GetTickLength() {
		return fTickLength;
	}
	void SetMaxEnergy(double en) {
		fMaxEnergy = en;
	}
	double GetMaxEnergy() {
		return fMaxEnergy;
	}
	void SetNBits(int n) {
		fNBits = n;
		fMaxADC = (int) std::pow(2, n) - 1;
	}
	int GetNBits() {
		return fNBits;
	}
	int GetMaxADC() {
		return fMaxADC;
	}
	void SetPedestal(int pe) {
		fPedestal = pe;
	}
	int GetPedestal() {
		return fPedestal;
	}
	void SetNSamples(int n) {
		fNSamples = n;
	}
	int GetNSamples() {
		return fNSamples;
	}
	void SetNPreSamples(int n) {
		fNPreSamples = n;
	}
	int GetNPreSamples() {
		return fNPreSamples;
	}

	//Global Setters
	void SetPulseProperties(double rt, double dt, double s, double th, int po);
	void SetDigitizationProperties(double fr, double maxen, int nbits, int ped,
			int nsamps, int npresamps);

private:
	void Noise(std::vector<int>& s);

public:
	bool IsOverThreshold(double e);
	TPulseIsland* GetGaussianResponse(double e, double t, const char* n);
	TPulseIsland* GetExponentialResponse(double e, double t, const char* n);
};

// Implementation
DetectorResponse::DetectorResponse() :
		fRandom(TRandom3()), fRiseTime(5.), fDecayTime(10.), fSigma(1000.), fThreshold(
				100.), fPolarity(1), fWhiteNoise(0.), fCalibration(1.), fFrequency(
				0.17), fTickLength(1 / 0.17), fMaxEnergy(10000.), fNBits(12), fMaxADC(
				4095), fPedestal(0), fNSamples(100), fNPreSamples(20) {
}

bool DetectorResponse::IsOverThreshold(double e) {
	return e > fThreshold;
}

void DetectorResponse::SetPulseProperties(double rt, double dt, double s,
		double th, int po) {
	fRiseTime = rt;
	fDecayTime = dt;
	fSigma = s;
	fThreshold = th;
	fPolarity = po;
}

void DetectorResponse::SetDigitizationProperties(double f, double e, int nb,
		int p, int ns, int nps) {
	fFrequency = f;
	fTickLength = 1. / f;
	fMaxEnergy = e;
	fNBits = nb;
	fMaxADC = (int) std::pow(2, nb) - 1;
	fPedestal = p;
	fNSamples = ns;
	fNPreSamples = nps;
}

void DetectorResponse::Noise(std::vector<int>& s) {
	for (unsigned int i = 0; i < s.size(); i++)
		s[i] += (int) fRandom.Gaus(0., fWhiteNoise);
}

TPulseIsland* DetectorResponse::GetGaussianResponse(double e, double t,
		const char* n) {
	std::string name(n);
	std::vector<int> samples;
	std::vector<double> energies;
	int iSample;
	int adc;
	int sampleOver = -1;
	double loct = 0.;
	for (iSample = 0; iSample < fNSamples; iSample++) {
		energies.push_back(
				fCalibration * e
						* std::exp(
								-std::pow(loct - 3. * fSigma, 2)
										/ (2 * std::pow(fSigma, 2))));
		loct += fTickLength;
		if (sampleOver < 0 && IsOverThreshold(energies.at(iSample)))
			sampleOver = iSample;
	}
	int nPreSamples = fNPreSamples - sampleOver;
	for (iSample = 0; iSample < nPreSamples; iSample++)
		samples.push_back(fPedestal);
	for (; iSample < fNSamples; iSample++) {
		adc = fPedestal
				+ fPolarity
						* std::floor(
								((double) fMaxADC) / fMaxEnergy
										* energies[iSample - nPreSamples]);
		if (adc > fMaxADC)
			adc = fMaxADC;
		else if (adc < 0)
			adc = 0;
		samples.push_back(adc);
	}
	Noise(samples);
	return new TPulseIsland(t / fTickLength - nPreSamples, samples, fTickLength,
			name);
}

TPulseIsland* DetectorResponse::GetExponentialResponse(double e, double t,
		const char* n) {
	std::string name(n);
	std::vector<int> samples;
	std::vector<double> energies;
	int iSample;
	int adc;
	int sampleOver = -1;
	double loct = 0.;
	for (iSample = 0; iSample < fNSamples; iSample++) {
		energies.push_back(
				fCalibration * e
						* (std::exp(-loct / fDecayTime)
								- std::exp(-loct / fRiseTime)));
		loct += fTickLength;
		if (sampleOver < 0 && IsOverThreshold(energies.at(iSample)))
			sampleOver = iSample;
	}
	int nPreSamples = fNPreSamples - sampleOver;
	for (iSample = 0; iSample < nPreSamples; iSample++)
		samples.push_back(fPedestal);
	for (; iSample < fNSamples; iSample++) {
		adc = fPedestal
				+ fPolarity
						* std::floor(
								((double) fMaxADC) / fMaxEnergy
										* energies[iSample - nPreSamples]);
		if (adc > fMaxADC)
			adc = fMaxADC;
		else if (adc < 0)
			adc = 0;
		samples.push_back(adc);
	}
	Noise(samples);
	return new TPulseIsland(t / fTickLength - nPreSamples, samples, fTickLength,
			name);
}
